"""\nCache management for OBS YouTube Player.\nHandles existing cache scanning and cleanup.\n"""\n\nimport os\nfrom pathlib import Path\n\nfrom logger import log\nfrom state import (\n    get_cache_dir, get_cached_videos, add_cached_video, \n    remove_cached_video, get_playlist_video_ids,\n    is_video_being_processed, get_cached_video_info,\n    get_current_playback_video_id\n)\nfrom utils import validate_youtube_id\n\ndef validate_video_file(file_path):\n    """Check if video file is valid and playable."""\n    try:\n        if not os.path.exists(file_path):\n            return False\n        \n        # Check minimum file size (1MB)\n        file_size = os.path.getsize(file_path)\n        if file_size < 1024 * 1024:\n            return False\n            \n        # Check if it's a valid video file by extension\n        valid_extensions = ['.mp4', '.webm', '.mkv']\n        if not any(file_path.lower().endswith(ext) for ext in valid_extensions):\n            return False\n            \n        return True\n    except Exception:\n        return False\n\ndef scan_existing_cache():\n    """Scan cache directory for existing normalized videos."""\n    cache_path = Path(get_cache_dir())\n    if not cache_path.exists():\n        return\n    \n    log("Scanning cache for existing videos...")\n    found_count = 0\n    debug_count = 0\n    skipped_count = 0\n    gemini_failed_count = 0\n    \n    # Look for normalized videos (both with and without _gf marker)\n    for file_path in cache_path.glob("*_normalized*.mp4"):\n        debug_count += 1\n        \n        # Validate the video file\n        if not validate_video_file(str(file_path)):\n            log(f"Skipping invalid video file: {file_path.name}")\n            skipped_count += 1\n            continue\n            \n        try:\n            # Extract video ID from filename\n            # Format: song_artist_videoId_normalized.mp4 or song_artist_videoId_normalized_gf.mp4\n            filename = file_path.stem  # Remove .mp4\n            \n            # Check if this is a Gemini failed file\n            gemini_failed = False\n            if filename.endswith('_gf'):\n                gemini_failed = True\n                gemini_failed_count += 1\n                # Remove _gf suffix for parsing\n                filename = filename[:-3]\n            \n            # Must end with _normalized\n            if not filename.endswith('_normalized'):\n                continue\n                \n            # Remove _normalized suffix\n            without_suffix = filename[:-11]  # len('_normalized') = 11\n            \n            # Find video ID by searching from the end\n            # YouTube IDs are 11 characters and can contain letters, numbers, - and _\n            parts = without_suffix.split('_')\n            \n            # Try to find a valid YouTube ID from the end\n            video_id = None\n            for i in range(len(parts) - 1, -1, -1):\n                # Try combining parts to form an 11-character ID\n                for j in range(i, len(parts)):\n                    potential_id = '_'.join(parts[i:j+1])\n                    if validate_youtube_id(potential_id):\n                        video_id = potential_id\n                        # Everything before this is song_artist\n                        remaining = '_'.join(parts[:i])\n                        break\n                if video_id:\n                    break\n            \n            if not video_id:\n                log(f"Could not extract video ID from: {file_path.name}")\n                continue\n            \n            # Try to extract metadata from remaining part\n            # The remaining part is song_artist\n            if remaining:\n                # Try to split into song and artist\n                # The last part before video ID should be artist\n                remaining_parts = remaining.rsplit('_', 1)\n                if len(remaining_parts) == 2:\n                    song, artist = remaining_parts\n                else:\n                    song = remaining\n                    artist = "Unknown Artist"\n            else:\n                song = "Unknown Song"\n                artist = "Unknown Artist"\n            \n            # Add to cached videos\n            add_cached_video(video_id, {\n                'path': str(file_path),\n                'song': song.replace('_', ' '),\n                'artist': artist.replace('_', ' '),\n                'normalized': True,\n                'gemini_failed': gemini_failed\n            })\n            found_count += 1\n            \n            # Debug log for first few files\n            if debug_count <= 3:\n                status = " (Gemini failed)" if gemini_failed else ""\n                log(f"Scanned: {file_path.name} -> ID: {video_id}, Song: {song}, Artist: {artist}{status}")\n                        \n        except Exception as e:\n            log(f"Error scanning file {file_path}: {e}")\n    \n    if found_count > 0:\n        log(f"Found {found_count} existing videos in cache")\n        if gemini_failed_count > 0:\n            log(f"  - {gemini_failed_count} videos marked for Gemini retry")\n    if skipped_count > 0:\n        log(f"Skipped {skipped_count} invalid video files")\n    \n    # Return whether we found any videos that need reprocessing\n    return gemini_failed_count > 0\n\ndef cleanup_removed_videos():\n    """Remove videos that are no longer in playlist."""\n    playlist_ids = get_playlist_video_ids()\n    cached_videos = get_cached_videos()\n    \n    # Find videos to remove\n    videos_to_remove = []\n    current_playing_id = get_current_playback_video_id()\n    \n    for video_id in cached_videos:\n        if video_id not in playlist_ids:\n            # Check if it's currently playing\n            if video_id == current_playing_id:\n                log(f"Skipping removal of currently playing video: {video_id}")\n            else:\n                videos_to_remove.append(video_id)\n    \n    # Remove videos\n    for video_id in videos_to_remove:\n        video_info = get_cached_video_info(video_id)\n        if video_info:\n            try:\n                if os.path.exists(video_info['path']):\n                    os.remove(video_info['path'])\n                remove_cached_video(video_id)\n                log(f"Removed: {video_info['artist']} - {video_info['song']}")\n            except Exception as e:\n                log(f"Error removing video {video_id}: {e}")\n    \n    if videos_to_remove:\n        log(f"Cleaned up {len(videos_to_remove)} removed videos")\n\ndef cleanup_temp_files():\n    """Clean up any temporary files."""\n    try:\n        cache_path = Path(get_cache_dir())\n        if cache_path.exists():\n            # Clean up .part files\n            for part_file in cache_path.glob("*.part"):\n                try:\n                    os.remove(part_file)\n                    log(f"Removed temp file: {part_file.name}")\n                except Exception as e:\n                    log(f"Error removing {part_file}: {e}")\n            \n            # Clean up _temp.mp4 files\n            for temp_file in cache_path.glob("*_temp.mp4"):\n                try:\n                    os.remove(temp_file)\n                    log(f"Removed temp file: {temp_file.name}")\n                except Exception as e:\n                    log(f"Error removing {temp_file}: {e}")\n                    \n    except Exception as e:\n        log(f"Error during temp file cleanup: {e}")\n