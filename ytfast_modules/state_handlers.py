"""\nPlayback state handlers.\nHandles different media states: playing, ended, stopped, none.\n"""\n\nimport obspython as obs\nfrom logger import log\nfrom utils import format_duration\nfrom config import PLAYBACK_MODE_SINGLE, PLAYBACK_MODE_LOOP, MEDIA_SOURCE_NAME\nfrom state import (\n    is_playing, set_playing, get_current_playback_video_id,\n    set_current_playback_video_id, get_cached_video_info,\n    get_playback_mode, is_first_video_played, set_first_video_played,\n    get_loop_video_id, set_loop_video_id, get_cached_videos,\n    is_scene_active\n)\nfrom ytfast_modules.media_control import (\n    get_media_duration, get_media_time, get_current_video_from_media_source\n)\nfrom ytfast_modules.title_manager import (\n    SEEK_THRESHOLD, schedule_title_clear_from_current,\n    is_title_clear_scheduled, get_title_clear_timer,\n    cancel_title_timers\n)\n\n# Module-level variables\n_last_playback_time = 0  # Track last playback position for seek detection\n_loop_restart_timer = None  # Timer reference for loop restart\n_loop_restart_pending = False  # Track if we're waiting to restart loop\n_loop_restart_video_id = None  # Track which video we're restarting\n_manual_stop_detected = False  # Track if user manually stopped playback\n_last_progress_log = {}\n_playback_retry_count = 0\n_max_retry_attempts = 3\n_preloaded_video_handled = False  # Track if we've handled pre-loaded video\n_is_preloaded_video = False  # Track if current video is pre-loaded\n_title_clear_rescheduled = False  # Track if we've rescheduled after seek\n\n\ndef reset_playback_tracking():\n    """Reset playback tracking variables."""\n    global _last_playback_time, _last_progress_log, _playback_retry_count, _title_clear_rescheduled\n    _last_playback_time = 0\n    _last_progress_log.clear()\n    _playback_retry_count = 0\n    _title_clear_rescheduled = False\n\n\ndef log_playback_progress(video_id, current_time, duration):\n    """Log playback progress at intervals without spamming."""\n    global _last_progress_log\n    \n    # Log every 30 seconds\n    progress_key = f"{video_id}_{int(current_time/30000)}"\n    if progress_key not in _last_progress_log:\n        _last_progress_log[progress_key] = True\n        percent = int((current_time/duration) * 100)\n        \n        # Get video info for better logging\n        video_info = get_cached_video_info(video_id)\n        if video_info:\n            # Convert milliseconds to seconds and format\n            current_time_formatted = format_duration(current_time / 1000)\n            duration_formatted = format_duration(duration / 1000)\n            \n            log(f"Playing: {video_info['song']} - {video_info['artist']} "\n                f"[{percent}% - {current_time_formatted} / {duration_formatted}]")\n\n\ndef handle_playing_state():\n    """Handle currently playing video state."""\n    global _is_preloaded_video, _last_playback_time, _manual_stop_detected\n    global _loop_restart_pending, _loop_restart_video_id, _title_clear_rescheduled\n    \n    # Clear manual stop flag when playing\n    _manual_stop_detected = False\n    \n    # Check if we were waiting for a loop restart\n    if _loop_restart_pending and _loop_restart_video_id:\n        current_video_id = get_current_playback_video_id()\n        if current_video_id == _loop_restart_video_id:\n            # The loop video is now playing, clear the pending flag\n            log("Loop restart completed successfully")\n            _loop_restart_pending = False\n            _loop_restart_video_id = None\n    \n    # If media is playing but we don't think we're playing, sync the state\n    if not is_playing():\n        log("Media playing but state out of sync - updating state")\n        # Check if this is a valid video or just empty media source\n        duration = get_media_duration(MEDIA_SOURCE_NAME)\n        if duration <= 0:\n            # No valid media loaded, start fresh\n            log("No valid media loaded, starting playback")\n            # Import here to avoid circular dependency\n            from ytfast_modules.playback_controller import start_next_video\n            start_next_video()\n            return\n        # Valid media is playing, sync the state\n        set_playing(True)\n        \n        # Try to identify the current video if not already set\n        if not get_current_playback_video_id():\n            current_video_id = get_current_video_from_media_source()\n            if current_video_id:\n                set_current_playback_video_id(current_video_id)\n                log(f"Identified current video: {current_video_id}")\n                \n                # If we're in loop mode and no loop video set, set this one\n                if get_playback_mode() == PLAYBACK_MODE_LOOP and not get_loop_video_id():\n                    set_loop_video_id(current_video_id)\n                    log(f"Loop mode - Set current video as loop video: {current_video_id}")\n        \n        return\n    \n    duration = get_media_duration(MEDIA_SOURCE_NAME)\n    current_time = get_media_time(MEDIA_SOURCE_NAME)\n    \n    if duration > 0 and current_time > 0:\n        # Check for seek (large jump in playback position)\n        if _last_playback_time > 0:\n            time_diff = current_time - _last_playback_time\n            # If time jumped forward by more than threshold, it's likely a seek\n            if time_diff > SEEK_THRESHOLD:\n                log(f"Seek detected: jumped from {_last_playback_time/1000:.1f}s to {current_time/1000:.1f}s")\n                # Reset the rescheduled flag to allow rescheduling\n                _title_clear_rescheduled = False\n        \n        _last_playback_time = current_time\n        \n        # Log progress without spamming\n        video_id = get_current_playback_video_id()\n        if video_id:\n            log_playback_progress(video_id, current_time, duration)\n        \n        # Check if we need to schedule or reschedule title clear\n        remaining_ms = duration - current_time\n        \n        # Import here to avoid circular dependency\n        from ytfast_modules.title_manager import TITLE_CLEAR_BEFORE_END\n        \n        # Schedule fade out when we're close to the end\n        # We check for (TITLE_CLEAR_BEFORE_END + 5) seconds to give enough time for scheduling\n        if remaining_ms > 0 and remaining_ms < ((TITLE_CLEAR_BEFORE_END + 5) * 1000):\n            # Only reschedule if we haven't already done so after a seek\n            # or if no timer is currently scheduled\n            if not _title_clear_rescheduled or not is_title_clear_scheduled():\n                # Schedule the fade out based on current remaining time\n                schedule_title_clear_from_current(remaining_ms)\n                _title_clear_rescheduled = True\n                log(f"Title fade rescheduled for remaining time: {remaining_ms/1000:.1f}s")\n\n\ndef handle_ended_state():\n    """Handle video ended state."""\n    global _preloaded_video_handled, _is_preloaded_video, _loop_restart_pending\n    \n    # Reset playback tracking\n    reset_playback_tracking()\n    \n    playback_mode = get_playback_mode()\n    \n    if is_playing():\n        # Prevent loop mode from firing multiple times\n        if playback_mode == PLAYBACK_MODE_LOOP and _loop_restart_pending:\n            return  # Already scheduled a restart\n        \n        # Check if we need to loop\n        if playback_mode == PLAYBACK_MODE_LOOP:\n            # Get the video that just ended\n            current_video_id = get_current_playback_video_id()\n            if not current_video_id and _is_preloaded_video:\n                # Try to identify the pre-loaded video\n                current_video_id = get_current_video_from_media_source()\n            \n            if current_video_id:\n                # Make sure it's set as the loop video\n                if not get_loop_video_id():\n                    set_loop_video_id(current_video_id)\n                    log(f"Loop mode - Set ended video as loop video: {current_video_id}")\n                \n                log("Loop mode: Replaying the same video")\n                _loop_restart_pending = True\n                # Mark pre-loaded video as handled if it was one\n                if _is_preloaded_video:\n                    _preloaded_video_handled = True\n                    _is_preloaded_video = False\n                # Schedule restart with a single timer\n                schedule_loop_restart(current_video_id)\n                return\n            else:\n                log("Loop mode: Could not identify video to loop, selecting next")\n        \n        # Handle non-loop modes\n        if not _preloaded_video_handled and _is_preloaded_video:\n            log("Pre-loaded video ended")\n            _preloaded_video_handled = True\n            _is_preloaded_video = False\n            \n            # Check if we're in single mode\n            if playback_mode == PLAYBACK_MODE_SINGLE:\n                log("Single mode: Pre-loaded video counted as first video, stopping playback")\n                # Mark that first video has been played\n                set_first_video_played(True)\n                # Import here to avoid circular dependency\n                from ytfast_modules.playback_controller import stop_current_playback\n                stop_current_playback()\n                return\n            else:\n                log("Starting playlist after pre-loaded video")\n        else:\n            # Regular video ended (not pre-loaded)\n            # Check playback mode to determine what to do next\n            if playback_mode == PLAYBACK_MODE_SINGLE and is_first_video_played():\n                log("Single mode: First video ended, stopping playback")\n                # Import here to avoid circular dependency\n                from ytfast_modules.playback_controller import stop_current_playback\n                stop_current_playback()\n                return\n            else:\n                # Continuous mode or first video not played yet\n                log("Playback ended, starting next video")\n        \n        # Import here to avoid circular dependency\n        from ytfast_modules.playback_controller import start_next_video\n        start_next_video()\n    elif is_scene_active() and get_cached_videos():\n        # Check if we're in single mode and already played first video\n        if playback_mode == PLAYBACK_MODE_SINGLE and is_first_video_played():\n            # Don't start new playback in single mode after first video\n            return\n        # Not playing but scene is active and we have videos - start playback\n        log("Scene active and videos available, starting playback")\n        # Import here to avoid circular dependency\n        from ytfast_modules.playback_controller import start_next_video\n        start_next_video()\n\n\ndef schedule_loop_restart(video_id):\n    """Schedule a single restart of the loop video."""\n    global _loop_restart_timer, _loop_restart_video_id\n    \n    # Store the video ID we're restarting\n    _loop_restart_video_id = video_id\n    \n    # Cancel any existing timer\n    if _loop_restart_timer:\n        obs.timer_remove(_loop_restart_timer)\n        _loop_restart_timer = None\n    \n    # Create a closure that captures the video_id\n    def restart_callback():\n        global _loop_restart_timer\n        # Remove the timer reference\n        if _loop_restart_timer:\n            obs.timer_remove(_loop_restart_timer)\n            _loop_restart_timer = None\n        # Don't clear _loop_restart_pending here - wait until video is actually playing\n        # Import here to avoid circular dependency\n        from ytfast_modules.playback_controller import start_specific_video\n        start_specific_video(video_id)\n    \n    # Schedule the restart with a longer delay to ensure media source is ready\n    _loop_restart_timer = restart_callback\n    obs.timer_add(_loop_restart_timer, 1000)  # Increased to 1 second for better stability\n\n\ndef handle_stopped_state():\n    """Handle video stopped state."""\n    global _manual_stop_detected, _playback_retry_count\n    \n    if is_playing():\n        # Check if this was a manual stop (we didn't initiate it)\n        if not _manual_stop_detected:\n            _manual_stop_detected = True\n            log("Manual stop detected - user clicked stop button")\n            \n            # Clear loop video if in loop mode\n            if get_playback_mode() == PLAYBACK_MODE_LOOP:\n                log("Clearing loop video due to manual stop")\n                set_loop_video_id(None)\n            \n            # Stop playback cleanly\n            # Import here to avoid circular dependency\n            from ytfast_modules.playback_controller import stop_current_playback\n            stop_current_playback()\n            return\n        \n        log("Playback stopped, attempting to resume or skip")\n        # Try to resume or skip to next\n        if _playback_retry_count < _max_retry_attempts:\n            _playback_retry_count += 1\n            log(f"Retry attempt {_playback_retry_count}")\n            # Import here to avoid circular dependency\n            from ytfast_modules.playback_controller import start_next_video\n            start_next_video()\n        else:\n            log("Max retries reached, stopping playback")\n            # Import here to avoid circular dependency\n            from ytfast_modules.playback_controller import stop_current_playback\n            stop_current_playback()\n\n\ndef handle_none_state():\n    """Handle no media loaded state."""\n    if is_scene_active() and not is_playing():\n        # Only start if we have videos available\n        if get_cached_videos():\n            playback_mode = get_playback_mode()\n            \n            # Check restrictions based on mode\n            if playback_mode == PLAYBACK_MODE_SINGLE and is_first_video_played():\n                # Don't start new playback in single mode after first video\n                return\n            elif playback_mode == PLAYBACK_MODE_LOOP:\n                # In loop mode, clear the loop video when scene becomes active\n                # This ensures a new random video is selected\n                if get_loop_video_id():\n                    log("Loop mode: Clearing previous loop video to select new random video")\n                    set_loop_video_id(None)\n                \n            log("Scene active and videos available, starting playback")\n            # Import here to avoid circular dependency\n            from ytfast_modules.playback_controller import start_next_video\n            start_next_video()\n    elif is_scene_active() and is_playing():\n        # This shouldn't happen - playing but no media?\n        log("WARNING: Playing state but no media loaded - resetting state")\n        set_playing(False)\n\n\ndef cancel_loop_restart_timer():\n    """Cancel any pending loop restart timer."""\n    global _loop_restart_timer\n    if _loop_restart_timer:\n        obs.timer_remove(_loop_restart_timer)\n        _loop_restart_timer = None\n\n\ndef set_preloaded_video_state(handled, is_preloaded):\n    """Set pre-loaded video state."""\n    global _preloaded_video_handled, _is_preloaded_video\n    _preloaded_video_handled = handled\n    _is_preloaded_video = is_preloaded\n\n\ndef set_manual_stop_detected(detected):\n    """Set manual stop detected flag."""\n    global _manual_stop_detected\n    _manual_stop_detected = detected\n\n\ndef clear_loop_restart_state():\n    """Clear loop restart state."""\n    global _loop_restart_pending, _loop_restart_video_id\n    _loop_restart_pending = False\n    _loop_restart_video_id = None\n